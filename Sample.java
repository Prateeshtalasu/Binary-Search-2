//Find First and Last Position of Element in Sorted Array
// time complexity O(logn)
//space complexity O(1)
//i am using binary search to find the first and last occurence of the target element
//i am using two binary search to find the first and last occurence of the target element

class Solution {

    public int[] searchRange(int[] nums, int target) {
        if (nums ==null || nums.length==0){
            return new int [] {-1,-1};
        }
        int first = firstOccurence(nums,target);
        if (first == -1){
            return new int [] {-1,-1};
        }
        int last = lastOccurence(nums,target);
        return new int [] {first,last};

    public int firstOccurence(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int firstpostion = -1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                firstpostion = mid;
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }

        }

        return firstpostion;
    }

    public int lastOccurence(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int lastpostion = -1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                lastpostion = mid;
                left = mid + 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return lastpostion;

    }

}}

    /////////////////////////////////////////////////////////////////////////////////////////
    ///
    /// 153. Find Minimum in Rotated Sorted Array
    /// time complexity O(logn)
    /// space complexity O(1)
    /// i am using binary search to find the minimum element in the rotated sorted
    ///////////////////////////////////////////////////////////////////////////////////////// array
    ///////////////////////////////////////////////////////////////////////////////////////// where
    ///////////////////////////////////////////////////////////////////////////////////////// the
    ///////////////////////////////////////////////////////////////////////////////////////// array
    ///////////////////////////////////////////////////////////////////////////////////////// is
    ///////////////////////////////////////////////////////////////////////////////////////// sorted
    ///////////////////////////////////////////////////////////////////////////////////////// in
    ///////////////////////////////////////////////////////////////////////////////////////// ascending
    ///////////////////////////////////////////////////////////////////////////////////////// order
    ///////////////////////////////////////////////////////////////////////////////////////// so
    ///////////////////////////////////////////////////////////////////////////////////////// min
    ///////////////////////////////////////////////////////////////////////////////////////// element
    ///////////////////////////////////////////////////////////////////////////////////////// is
    ///////////////////////////////////////////////////////////////////////////////////////// always
    ///////////////////////////////////////////////////////////////////////////////////////// left
    ///////////////////////////////////////////////////////////////////////////////////////// if
    ///////////////////////////////////////////////////////////////////////////////////////// its
    ///////////////////////////////////////////////////////////////////////////////////////// sorted
    ///////////////////////////////////////////////////////////////////////////////////////// otherwirse
    ///////////////////////////////////////////////////////////////////////////////////////// on
    ///////////////////////////////////////////////////////////////////////////////////////// right
    ///////////////////////////////////////////////////////////////////////////////////////// where
    ///////////////////////////////////////////////////////////////////////////////////////// left
    ///////////////////////////////////////////////////////////////////////////////////////// =mid+1
    ///
    ///
    ///
    ///
    /// class Solution {
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < nums[right]) {
                right = mid;
            } else if (nums[mid] > nums[right]) {
                left = mid + 1;

            }
        }

        return nums[left];

    }
}

///////////////////////////////////////////////////////////////////////////////////////
///
/// Find Peak Element
/// time complexity O(logn)
/// space complexity O(1)
/// i am using binary search to find the peak element in the array
/// In the "Find Peak Element" problem, we use binary search to always move
/////////////////////////////////////////////////////////////////////////////////////// toward
/////////////////////////////////////////////////////////////////////////////////////// a
/////////////////////////////////////////////////////////////////////////////////////// direction
/////////////////////////////////////////////////////////////////////////////////////// where
/////////////////////////////////////////////////////////////////////////////////////// a
/////////////////////////////////////////////////////////////////////////////////////// peak
/////////////////////////////////////////////////////////////////////////////////////// is
/////////////////////////////////////////////////////////////////////////////////////// guaranteed.
/////////////////////////////////////////////////////////////////////////////////////// If
/////////////////////////////////////////////////////////////////////////////////////// nums[mid]
/////////////////////////////////////////////////////////////////////////////////////// <
/////////////////////////////////////////////////////////////////////////////////////// nums[mid+1],
/////////////////////////////////////////////////////////////////////////////////////// we
/////////////////////////////////////////////////////////////////////////////////////// go
/////////////////////////////////////////////////////////////////////////////////////// right
/////////////////////////////////////////////////////////////////////////////////////// because
/////////////////////////////////////////////////////////////////////////////////////// there's
/////////////////////////////////////////////////////////////////////////////////////// an
/////////////////////////////////////////////////////////////////////////////////////// uphill
/////////////////////////////////////////////////////////////////////////////////////// slope,
/////////////////////////////////////////////////////////////////////////////////////// meaning
/////////////////////////////////////////////////////////////////////////////////////// a
/////////////////////////////////////////////////////////////////////////////////////// peak
/////////////////////////////////////////////////////////////////////////////////////// must
/////////////////////////////////////////////////////////////////////////////////////// exist
/////////////////////////////////////////////////////////////////////////////////////// there.
/////////////////////////////////////////////////////////////////////////////////////// If
/////////////////////////////////////////////////////////////////////////////////////// nums[mid]
/////////////////////////////////////////////////////////////////////////////////////// >
/////////////////////////////////////////////////////////////////////////////////////// nums[mid+1],
/////////////////////////////////////////////////////////////////////////////////////// we
/////////////////////////////////////////////////////////////////////////////////////// go
/////////////////////////////////////////////////////////////////////////////////////// left
/////////////////////////////////////////////////////////////////////////////////////// since
/////////////////////////////////////////////////////////////////////////////////////// mid
/////////////////////////////////////////////////////////////////////////////////////// could
/////////////////////////////////////////////////////////////////////////////////////// be
/////////////////////////////////////////////////////////////////////////////////////// a
/////////////////////////////////////////////////////////////////////////////////////// peak
/////////////////////////////////////////////////////////////////////////////////////// or
/////////////////////////////////////////////////////////////////////////////////////// a
/////////////////////////////////////////////////////////////////////////////////////// peak
/////////////////////////////////////////////////////////////////////////////////////// lies
/////////////////////////////////////////////////////////////////////////////////////// on
/////////////////////////////////////////////////////////////////////////////////////// the
/////////////////////////////////////////////////////////////////////////////////////// left.
/////////////////////////////////////////////////////////////////////////////////////// We
/////////////////////////////////////////////////////////////////////////////////////// return
/////////////////////////////////////////////////////////////////////////////////////// left
/////////////////////////////////////////////////////////////////////////////////////// (or
/////////////////////////////////////////////////////////////////////////////////////// right)
/////////////////////////////////////////////////////////////////////////////////////// at
/////////////////////////////////////////////////////////////////////////////////////// the
/////////////////////////////////////////////////////////////////////////////////////// end
/////////////////////////////////////////////////////////////////////////////////////// because
/////////////////////////////////////////////////////////////////////////////////////// both
/////////////////////////////////////////////////////////////////////////////////////// pointers
/////////////////////////////////////////////////////////////////////////////////////// converge
/////////////////////////////////////////////////////////////////////////////////////// on
/////////////////////////////////////////////////////////////////////////////////////// a
/////////////////////////////////////////////////////////////////////////////////////// peak
/////////////////////////////////////////////////////////////////////////////////////// element
///
///

class Solution {
    public int findPeakElement(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < nums[mid + 1]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return left; // or return right; both are same now

    }
}